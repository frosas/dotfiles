/**
 * DCTK interface for the Abacus A/B testing platform.
 */
 
/* eslint-env browser, node */

var dctk = require('../dctk');
var util = require('../analytics/util');
var StorageAccess = require('./StorageAccess');
var time = require('../time');
var dctkUtil = require('../dctk/util');
<<<<<<< HEAD
var bucketingService = require('../abacus/bucketing-service');
=======
var Promise = require('yaku');
var objectAssign = require('object-assign');

>>>>>>> 753c80f... _useExperiment() → _useExperiments()
var deferredExecution = require('./deferredExecution');
var abacus = require('../abacus');

var loggedExperimentsStorage = new StorageAccess('seen_experiments');
dctk._loggedExperiments = util.filter(loggedExperimentsStorage.load([]), (function () {
    "use strict";
    var TIMESTAMP_EXPIRATION_THRESHOLD;

    TIMESTAMP_EXPIRATION_THRESHOLD = 30 * time.MINUTES;

    // for backwards compatibility reasons we need this.
    function hasNoTimestamp(experiment) {
        return !experiment.timeStamp;
    }

    function isNotExpired(experiment) {
        return (time.now() - experiment.timeStamp) < TIMESTAMP_EXPIRATION_THRESHOLD;
    }

    return function (experiment) {
        return hasNoTimestamp(experiment) || isNotExpired(experiment);
    };
}()));

dctk._trackExperimentsQueue = function (experiments) {
    dctk._trackExperimentToOmniture(experiments, function () {
        deferredExecution.clearQueue(deferredExecution.LOG_EXPERIMENT_TO_OMNITURE);
    });
};

dctk._runQueue = function () {
    deferredExecution.callWithQueue(deferredExecution.LOG_EXPERIMENT_TO_OMNITURE, dctk._trackExperimentsQueue);
};

dctk._initializeExperimentQueueManagement = function () {
    dctk._runQueue();
    window.setInterval(dctk._runQueue, 3000);
};

<<<<<<< HEAD
function createExperimentFromError(error) {
    "use strict";
    return {
        error : error,
        value : abacus.EXPERIMENT_CONTROL_VALUE
    };
=======
function updateExperimentsFromError(experiments, error) {
    return util.map(experiments, function(experiment) {
        return objectAssign({}, experiment, {
            error: error,
            value: abacus.EXPERIMENT_CONTROL_VALUE
        });
    });
>>>>>>> 753c80f... _useExperiment() → _useExperiments()
}

function getUseExperimentsUrl(log) {
    "use strict";
    var baseUrl = '/api/bucketing/v1'; // Provided by Hopscotch
    return baseUrl + (log
        ? '/evaluateExperimentsAndLog'
        : '/evaluateExperiments');
}

<<<<<<< HEAD
=======
function getGuid(explicitGuid) {
    "use strict";
    return explicitGuid || dctk._guid || analytics.getGuid().getLong();
}

function getTpid(explicitTpid) {
    "use strict";
    var analyticsGetTpid = analytics.getTpid();
    return explicitTpid !== undefined ? explicitTpid :
        dctk._tpid !== undefined ? dctk._tpid :
        analyticsGetTpid !== null ? Number(analyticsGetTpid) :
        null;
}

function getEapid(explicitEapid) {
    "use strict";
    var analyticsGetEapid = analytics.getEapid();
    return explicitEapid !== undefined ? explicitEapid :
        dctk._eapid !== undefined ? dctk._eapid :
        analyticsGetEapid !== null ? Number(analyticsGetEapid) :
        null;
}

/**
 * See https://ewegithub.sb.karmalab.net/EWE/abacus-experiment-api-server
 */
dctk._getUseExperimentsData = function (params) {
    "use strict";
    var data, abovCookie;

    data = {
        guid: getGuid(params.guid),
        tpid: getTpid(params.tpid),
        eapid: getEapid(params.eapid),
        verbose: true
    };
    
    data.id = util.reduce(params.experiments, function(ids, experiment) {
        if (experiment.id) return (ids || []).concat(experiment.id);
    }, undefined);
    
    data.name = util.reduce(params.experiments, function(names, experiment) {
        if (experiment.name) return (names || []).concat(experiment.name);
    }, undefined);

    data.pageName = params.pageName || (dctk.omtr && dctk.omtr.pageName) || dctk._pageName;

    abovCookie = cookies.get('abov');
    if (abovCookie) {
        data.overrides = abovCookie;
    }

    return data;
};

>>>>>>> 753c80f... _useExperiment() → _useExperiments()
/**
* @param {Object} response A bucketing service response
* @returns {Error|undefined} An error based on the response or undefined if no 
*     error occurred.
*/
function getUseExperimentsError(response, index) {
    var message =
        util.get(response, ['body', 'evaluatedExperiments', index, 'message']) || // Experiment specific errors (e.g. invalid ID)
        util.get(response, 'body.message'); // Request general errors (e.g. missing TPID)
    if (message && (message.type === 'ERROR' || message.type === 'WARN')) {
        var errorMessage = message.id;
        if (message.description) errorMessage += ' (' + message.description + ')';
        return new Error(errorMessage);
    }
}

function getUseExperimentsValue(response, index) {
    "use strict";
<<<<<<< HEAD
    return util.get(response, 'body.evaluatedExperiments.0.value', abacus.EXPERIMENT_CONTROL_VALUE);
=======
    return util.get(response, ['body', 'evaluatedExperiments', index, 'value'], abacus.EXPERIMENT_CONTROL_VALUE);
>>>>>>> 753c80f... _useExperiment() → _useExperiments()
}

function experimentIsLogged(experiment) {
    "use strict";
    return util.some(dctk._loggedExperiments, function (loggedExperiment) {
        return (
            loggedExperiment.id === experiment.id &&
            loggedExperiment.value === experiment.value
            );
    });
}

/**
 * @param  {Object} experiment
 * @param  {String} experiment.id
 * @param  {String} experiment.value Its bucket value
 * @return {boolean} Whether the experiment has been marked (because it wasn't)
 */
function markExperimentAsLogged(experiment) {
    "use strict";
    if (experimentIsLogged(experiment)) {
        return true;
    }
    dctk._loggedExperiments.push({
        id : experiment.id,
        value : experiment.value,
        timeStamp : time.now()
    });
    try {
        loggedExperimentsStorage.save(dctk._loggedExperiments);
    } catch (ignore) {
        // Ignored
    }

    return false;
}

dctk._trackExperimentToOmniture = function (experiments, callback) {
    "use strict";
    var i, numberOfExperiments, newExperiments, currentExperiment, wasLogged;

    numberOfExperiments = experiments.length;
    newExperiments = [];

    for (i = 0; i < numberOfExperiments; i += 1) {
        currentExperiment = experiments[i];
        wasLogged = markExperimentAsLogged({
            id : currentExperiment.id,
            value : currentExperiment.value
        });

        if (!wasLogged) {
            newExperiments.push(currentExperiment);
        }
    }

    if (newExperiments.length > 0) {
        dctk.onReady(function () {
            var i;

            dctk.omtr.linkTrackVars = '';

            for (i = 0; i < newExperiments.length; i += 1) {
                dctk.addExperiments(newExperiments[i].id + '.' + newExperiments[i].value);
            }

            dctk.trackEvent({
                name : 'Log Experiment',
                isUserBased : false
            });

            if (typeof callback === 'function') {
                callback();
            }
        });
    }
};

/**
 * Evaluates and logs an experiment to Abacus bucketing service (which, in turn,
 * logs it to UIS) and Omniture (if it was initialized, see `dctk.initOmniture()`).
 *
 * Consider using `dctk.logExperiment()` if all you need is to log the experiment
 * exposure. The functionality is the same but the name will express the intention
 * better.
 *
 * Example similar to the one in `dctk.logExperiment()` but evaluating the
 * experiment on the client side. Notice in this case the user experience can
 * be affected as it can take a few hundreds of milliseconds for `callback`
 * to be called:
 *
 * ```js
 * onHotelTabSelected(function () {
 *     dctk.evaluateExperimentAndLog({id: 1234, ..., callback: function (experiment) {
 *         if (experiment.error) setTimeout(function() { throw experiment.error; });
 *         if (experiment.value == 1) alert('...');
 *     }});
 * });
 * ```
 *
 * @api
 * @param {Object} params
 * @param {string} [params.guid] The [User GUID](https://dictionary/v/guid). It's
 *     not required when the library is loaded via the [JSP tag](loading.md) and
 *     a user interaction was passed to it.
 * @param {number} [params.tpid] The [Travel Product ID](https://dictionary/v/tpid).
 *     It's not required when the library is loaded via the [JSP tag](loading.md)
 *     and a user interaction was passed to it.
 * @param {number} [params.eapid] The [Expedia Affiliated Partner ID](https://dictionary/v/eapid).
 *     It's not required when the library is loaded via the [JSP tag](loading.md)
 *     and a user interaction was passed to it.
 * @param {string} [params.pageName] Required if Omniture hasn't been initialized
 *     (see `dctk.setupOmniture()`).
 * @param {number} [params.id] The ID of the experiment. Either this or `params.name`
 *     is required.
 * @param {string} [params.name] The name of the experiment. Either this or `params.id`
 *     is required.
 * @param {boolean} [params.logToOmniture] Whether to log to Omniture. `true` by default.
 * @param {Function} [params.callback] Called once it's done with the signature
 *     `function(experiment: {value: number, error?: Error})`, with `value` being 
 *     the bucket value the user was assigned to and `error` being set in case of 
 *     error.
 */
dctk.evaluateExperimentAndLog = function (params) {
    "use strict";
    params._log = true;
    this._useExperiments(params);
};

/**
 * Similar to `dctk.evaluateExperimentAndLog()` (see its documentation for the 
 * differences).
 *
 * Example where the experiment is evaluated on an FTL in the server side (using
 * Abacus Freemarker library) and then is logged on the client side:
 *
 * ```js
 * {#assign value = abacus.evaluateExperimentById(experimentId)}
 *
 * onHotelTabSelected(function () {
 *     // Log the experiment as soon as we read `value`
 *     dctk.logExperiment({id: ${experimentId}});
 *     if (${value} == 1) alert('...');
 * });
 * ```
 *
 * @api
 */
dctk.logExperiment = function (params) {
    "use strict";
    this.evaluateExperimentAndLog(params);
};

/**
 * Evaluates and logs multiple experiments to the Abacus bucketing service 
 * (which, in turn, logs it to UIS) and Omniture (if it was initialized, see 
 * `dctk.initOmniture()`).
 * 
 * It's basically the same as logExperiment, but with the opportunity to log 
 * multiple experiments by `id` or `name`.
 *
 * @param {Object}          params
 * @param {String} [params.guid] The [User GUID](https://dictionary/v/guid). By 
 *     default either the GUID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the GUID in the browser cookie will be used.
 * @param {Number} [params.tpid] The [Travel Product ID](https://dictionary/v/tpid).
 *     By default either the TPID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the TPID in the browser cookie will be used.
 * @param {Number} [params.eapid] The [Expedia Affiliated Partner ID](https://dictionary/v/eapid).
 *     By default either the EAPID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the EAPID in the browser cookie will be used.
 * @param {String}         [params.pageName]      Required if Omniture hasn't been 
 *                                                initialized (see `dctk.setupOmniture()`).
 * @param {Array.<Number>} [params.ids]           Any array of the ID of 
 *                                                experiments. Either this or 
 *                                                `params.names` is required.
 * @param {Array.<String>} [params.names]         The name of the experiments. 
 *                                                Either this or `params.ids` is 
 *                                                required.
 * @param {Boolean}        [params.logToOmniture] Whether to log to Omniture. `true` 
 *                                                by default.
 * @param {Function}       [params.callback]      Called once it's done, with the 
 *                                                signature `function(experiment: {value: number, error?: Error})`, 
 *                                                with `value` being the bucket value 
 *                                                the user was assigned to and `error` 
 *                                                being set in case of error.
 *                                                
 * @example
 * dctk.logExperiments({
 *    ids : [123,456,789]
 * });
 */
dctk.logExperiments = function (params) {
    "use strict";
    this.evaluateExperimentAndLog({
        guid : params.guid,
        tpid : params.tpid,
        eapid : params.eapid,
        pageName : params.pageName,
        id : params.ids,
        name : params.names,
        logToOmniture : params.logToOmniture
    });
};

/**
 * Evaluates an experiment (i.e. bucket the user into one of the
 * experiment variants)
 *
 * Usually you'll want to use this method when the page loads in order to avoid
 * using `dctk.evaluateExperimentAndLog()` (because the added lag), but still
 * can't use server-side methods like `abacus.evaluateExperiment()`.
 *
 * The current asynchronous interface (using `callback`) makes this method quite
 * hard to use. Please, contact us to discuss better alternatives (like using
 * Promises).
 *
 * @api
 * @param {Object} params
 * @param {String} [params.guid] The [User GUID](https://dictionary/v/guid). By 
 *     default either the GUID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the GUID in the browser cookie will be used.
 * @param {Number} [params.tpid] The [Travel Product ID](https://dictionary/v/tpid).
 *     By default either the TPID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the TPID in the browser cookie will be used.
 * @param {Number} [params.eapid] The [Expedia Affiliated Partner ID](https://dictionary/v/eapid).
 *     By default either the EAPID in UserInteraction object passed to the [JSP tag](loading.md)
 *     or the EAPID in the browser cookie will be used.
 * @param {string} [params.pageName] Required if Omniture hasn't been initialized
 *     (see `dctk.setupOmniture()`).
 * @param {number} [params.id] The ID of the experiment. Either this or `params.name`
 *     is required.
 * @param {string} [params.name] The name of the experiment. Either this or `params.id`
 *     is required.
 * @param {Function} [params.callback] Called once it's done with the signature
 *     `function(experiment: {value: number, error?: Error})`, with `value`
 *     being `0` and `error` being populated in case of error.
 */
dctk.evaluateExperiment = function (params) {
    "use strict";
    this._useExperiments(params);
};

/**
 * Makes use of an experiment, by evaluating and/or logging it against Abacus
 * bucketing service (UIS) and Omniture
 *
 * @param {Object} params
 * @param {string} [params.guid] The [User GUID](https://dictionary/v/guid)
 * @param {number} [params.tpid] The [Travel Product ID](https://dictionary/v/tpid)
 * @param {number} [params.eapid] The [Expedia Affiliated Partner ID](https://dictionary/v/eapid)
 * @param {number} [params.id] The ID of the experiment
 * @param {string} [params.name] The name of the experiment
 * @param {Function} [params.callback] Called once it's done with the signature
 *     `function(experiment: {error, value: number})`. In case of error `value`
 *     equals `0`. By default, in case of error, it throws the error.
 * @param {boolean} [params.logToOmniture] Whether to log to Omniture. `true` by default.
 * @param {Function} [params._bucketingRequest] The function in charge of doing
 *     the request against the bucketing service. Used for testing purposes.
 * @param {boolean} [params._log] Whether to log or not. `false` by default.
 * @param {Function} [params._onBucketingServiceResponse] Used for testing purposes
 * @returns {Promise} An always-resolving promise with the same `experiment` object
 *     being passed to `params.callback`.
 */
dctk._useExperiments = function (params) {
    "use strict";
    if (params.logToOmniture == null) {
        params.logToOmniture = true;
    }
    // Throw errors by default. We won't break the execution flow, the user
    // will be able to see the error in the browser console and client
    // logging will take care of logging it.
    if (!params.callback) {
        params.callback = function (experiments) {
            util.map(experiments, function(experiment) {
                if (experiment.error) util.warn(experiment.error);
            });
        };
    }
    if (!params._onBucketingServiceResponse) {
        params._onBucketingServiceResponse = function () {};
    }
<<<<<<< HEAD

    return (
        (params._bucketingRequest || dctkUtil.request)({
            url: getUseExperimentUrl(params._log),
            body: bucketingService.getRequestBody(params)
        })
        .then(function (response) {
            return {
                error : getUseExperimentError(response),
                value : getUseExperimentValue(response),
                experiments : util.get(response, 'body.evaluatedExperiments', []),
                id : util.get(response, 'body.evaluatedExperiments.0.id')
            };
        })
        .then(function (experiment) {
            params._onBucketingServiceResponse(experiment);

            if (params._log && params.logToOmniture && !experiment.error) {
                deferredExecution.addToQueue(deferredExecution.LOG_EXPERIMENT_TO_OMNITURE, experiment.experiments);
=======
        
    var idType = params.id ? 'id' : 'name'; // Either IDs or names are allowed.
    var experiments = util.map([].concat(params[idType]), function(id) {
        var experiment = {};
        experiment[idType] = id;
        return experiment;
    });
    
    return Promise.resolve()
        .then(function() {
            return (params._bucketingRequest || dctkUtil.request)({
                url : getUseExperimentsUrl(params._log),
                body : dctk._getUseExperimentsData(objectAssign({}, params, {
                    experiments: experiments
                }))
            });
        })
        .then(
            function (response) {
                return util.map(experiments, function(experiment, index) {
                    return {
                        error: getUseExperimentsError(response, index),
                        value: getUseExperimentsValue(response, index),
                        id: util.get(response, ['body', 'evaluatedExperiments', index, 'id'])
                    };
                });
            },
            function(error) {
                return updateExperimentsFromError(experiments, error);
            }
        )
        .then(function (experiments) {
            params._onBucketingServiceResponse(experiments);

            if (params._log && params.logToOmniture) {
                deferredExecution.addToQueue(
                    deferredExecution.LOG_EXPERIMENT_TO_OMNITURE,
                    util.filter(experiments, function(experiment) {
                        return !experiment.error;
                    })
                );
>>>>>>> 753c80f... _useExperiment() → _useExperiments()
            }

            return experiments;
        })
<<<<<<< HEAD
        ['catch'](createExperimentFromError) // eslint-disable-line no-unexpected-multiline
        .then(function(experiment) {
            // Call callback but detach from its outcome
            setTimeout(function() { params.callback(experiment); });
            return experiment;
        })
    );
=======
        .then(
            function (experiments) {
                params.callback(experiments[0]);
            },
            function (error) {
                params.callback(updateExperimentsFromError(experiments, error)[0]);
            }
        );
>>>>>>> 753c80f... _useExperiment() → _useExperiments()
};
