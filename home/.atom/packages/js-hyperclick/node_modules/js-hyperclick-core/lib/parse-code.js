"use strict";
"use babel";

// TimeCop was reporting that it took over 600ms for js-hyperclick to start.
// Converting this `import` to a `require` reduced it to under 250ms Moving it
// to require inside `findIdentifiers` and `parseCode` moved it off the TimeCop
// list (under 5ms)

/*
import { parse, traverse, types as t } from 'babel-core'
*/

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = parseCode;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var parseErrorTag = Symbol();

var identifierReducer = function identifierReducer(tmp, node) {
    var value = node;
    if (node.value) {
        value = node.value;
    }

    var _require = require('babel-core'),
        t = _require.types;

    var newIdentifiers = void 0;
    if (t.isIdentifier(value)) {
        newIdentifiers = [value];
    } else if (t.isObjectPattern(value)) {
        newIdentifiers = findIdentifiers(value);
    } else if (t.isArrayPattern(value)) {
        newIdentifiers = findIdentifiers(value);
    }

    /* istanbul ignore next: If this throws, it's a mistake in my code or an
    /* unsupported syntax */
    if (!newIdentifiers) {
        throw new Error("No identifiers found");
    }

    return [].concat(_toConsumableArray(tmp), _toConsumableArray(newIdentifiers));
};
function findIdentifiers(node) {
    var identifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var _require2 = require('babel-core'),
        t = _require2.types;

    if (t.isObjectPattern(node)) {
        return node.properties.reduce(identifierReducer, identifiers);
    } else if (t.isArrayPattern(node)) {
        return node.elements.reduce(identifierReducer, identifiers);
    } else if (t.isIdentifier(node)) {
        return [node];
    }
    /* istanbul ignore next */
    throw new Error('Unknown node type');
}

function parseCode(code) {
    var _require3 = require('babel-core'),
        traverse = _require3.traverse,
        t = _require3.types;

    var Hub = traverse.Hub,
        NodePath = traverse.NodePath;

    var _require4 = require('babylon'),
        parse = _require4.parse;

    var ast = undefined;

    try {
        ast = parse(code, {
            sourceType: "module",
            plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'decorators', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent']
        });
    } catch (parseError) {
        /* istanbul ignore next */
        return { parseError: parseError };
    }

    // console.log(JSON.stringify(ast, null, 4))

    var scopes = [];
    var externalModules = [];
    var exports = {};
    var paths = [];

    var addModule = function addModule(moduleName, identifier) {
        var imported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';

        externalModules.push({
            local: identifier.name,
            start: identifier.start,
            end: identifier.end,
            moduleName: moduleName,
            imported: imported
        });
    };
    var addUnboundModule = function addUnboundModule(moduleName, identifier) {
        var imported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identifier.name;

        paths.push({
            imported: imported,
            moduleName: moduleName,
            range: {
                start: identifier.start,
                end: identifier.end
            }
        });
    };

    var isModuleDotExports = function isModuleDotExports(node) {
        return t.isMemberExpression(node) && t.isIdentifier(node.object, { name: 'module' }) && t.isIdentifier(node.property, { name: 'exports' });
    };

    var visitors = {
        Scope: function Scope(_ref) {
            var scope = _ref.scope;

            scopes.push(scope);
        },
        CallExpression: function CallExpression(_ref2) {
            var node = _ref2.node,
                parent = _ref2.parent;

            if (t.isIdentifier(node.callee, { name: "require" })) {
                if (t.isLiteral(node.arguments[0])) {
                    (function () {
                        var moduleName = node.arguments[0].value;
                        var id = parent.id;


                        if (t.isAssignmentExpression(parent) && isModuleDotExports(parent.left)) {
                            addUnboundModule(moduleName, parent.left, 'default');
                        }

                        paths.push({
                            imported: 'default',
                            moduleName: moduleName,
                            range: {
                                start: node.arguments[0].start,
                                end: node.arguments[0].end
                            }
                        });

                        if (t.isIdentifier(id)) {
                            addModule(moduleName, id);
                        }
                        if (t.isObjectPattern(id) || t.isArrayPattern(id)) {
                            findIdentifiers(id).forEach(function (identifier) {
                                addModule(moduleName, identifier);
                            });
                        }
                    })();
                }
            }
        },
        ImportDeclaration: function ImportDeclaration(_ref3) {
            var node = _ref3.node;

            if (t.isLiteral(node.source)) {
                (function () {
                    var moduleName = node.source.value;
                    node.specifiers.forEach(function (_ref4) {
                        var local = _ref4.local,
                            imported = _ref4.imported;

                        var importedName = 'default';
                        if (imported != null) {
                            addUnboundModule(moduleName, imported);
                            importedName = imported.name;
                        }

                        addModule(moduleName, local, importedName);
                    });
                    paths.push({
                        imported: 'default',
                        moduleName: moduleName,
                        range: {
                            start: node.source.start,
                            end: node.source.end
                        }
                    });
                })();
            }
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref5) {
            var node = _ref5.node;
            var declaration = node.declaration;


            if (t.isIdentifier(declaration)) {
                exports.default = {
                    start: declaration.start,
                    end: declaration.end
                };
                return;
            }

            exports.default = {
                start: node.start,
                end: node.end
            };
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(_ref6) {
            var node = _ref6.node;
            var specifiers = node.specifiers,
                declaration = node.declaration;


            var moduleName = t.isLiteral(node.source) ? node.source.value : undefined;

            specifiers.forEach(function (spec) {
                if (t.isExportSpecifier(spec)) {
                    var _spec$exported = spec.exported,
                        name = _spec$exported.name,
                        start = _spec$exported.start,
                        end = _spec$exported.end;

                    exports[name] = { start: start, end: end };

                    // export ... from does not create a local binding, so I'm
                    // gathering it in the paths. build-suggestion will convert
                    // it back to a `from-module`
                    if (moduleName && t.isIdentifier(spec.local)) {
                        addUnboundModule(moduleName, spec.local);
                        // paths.push({
                        //     imported: spec.local.name,
                        //     moduleName,
                        //     range: {
                        //         start: spec.local.start,
                        //         end: spec.local.end,
                        //     }
                        // })
                    }
                } else if (t.isExportDefaultSpecifier(spec)) {
                    var _spec$exported2 = spec.exported,
                        _name = _spec$exported2.name,
                        _start = _spec$exported2.start,
                        _end = _spec$exported2.end;

                    exports[_name] = { start: _start, end: _end };

                    if (moduleName) {
                        paths.push({
                            imported: 'default',
                            moduleName: moduleName,
                            range: {
                                start: spec.exported.start,
                                end: spec.exported.end
                            }
                        });
                    }
                }
            });

            if (t.isVariableDeclaration(declaration)) {
                declaration.declarations.forEach(function (_ref7) {
                    var id = _ref7.id;

                    declaration.declarations.forEach;
                    findIdentifiers(id).forEach(function (_ref8) {
                        var name = _ref8.name,
                            start = _ref8.start,
                            end = _ref8.end;

                        exports[name] = { start: start, end: end };
                    });
                });
            }

            if (t.isFunctionDeclaration(declaration)) {
                var _declaration$id = declaration.id,
                    name = _declaration$id.name,
                    start = _declaration$id.start,
                    end = _declaration$id.end;

                exports[name] = { start: start, end: end };
            }

            if (moduleName) {
                paths.push({
                    imported: 'default',
                    moduleName: moduleName,
                    range: {
                        start: node.source.start,
                        end: node.source.end
                    }
                });
            }
        },
        ExportAllDeclaration: function ExportAllDeclaration(_ref9) {
            var node = _ref9.node;

            if (t.isLiteral(node.source)) {
                var moduleName = node.source.value;
                paths.push({
                    imported: 'default',
                    moduleName: moduleName,
                    range: {
                        start: node.source.start,
                        end: node.source.end
                    }
                });
            }
        },
        AssignmentExpression: function AssignmentExpression(_ref10) {
            var node = _ref10.node;

            if (isModuleDotExports(node.left)) {
                exports.default = {
                    start: node.left.start,
                    end: node.left.end
                };
            }
        }
    };

    try {
        var hub = new Hub({
            buildCodeFrameError: function buildCodeFrameError(node, message, Error) {
                var loc = node && (node.loc || node._loc);

                /* istanbul ignore else */
                if (loc) {
                    var err = new Error(message + " (" + loc.start.line + ":" + loc.start.column + ")");
                    err[parseErrorTag] = true;
                    return err;
                } else {
                    // Assume if we don't have a location, then it isn't a problem
                    // in the user's code and shouldn't be displayed as a parse
                    // error.
                    return new Error(message);
                }
            }
        });
        var path = NodePath.get({
            hub: hub,
            parentPath: null,
            parent: ast,
            container: ast,
            key: "program"
        }).setContext();
        // On order to capture duplicate declaration errors I have to build a
        // scope to get access to a "hub" that returns the error I need to catch.
        //
        // https://github.com/babel/babel/issues/4640
        traverse(ast, visitors, path.scope);
    } catch (e) {
        /* istanbul ignore else */
        if (e[parseErrorTag]) {
            return { parseError: e };
        } else {
            /* This should never trigger, it just rethrows unexpected errors */
            throw e;
        }
    }

    return {
        scopes: scopes,
        externalModules: externalModules,
        exports: exports,
        paths: paths
    };
}