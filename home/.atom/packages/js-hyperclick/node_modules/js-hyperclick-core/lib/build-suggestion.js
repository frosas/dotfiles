'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = buildSuggestion;
var scopeSize = function scopeSize(_ref) {
    var b = _ref.block;
    return b.end - b.start;
};

function findClosestScope(scopes, start, end) {
    return scopes.reduce(function (closest, scope) {
        var block = scope.block;


        if (block.start <= start && block.end >= end && scopeSize(scope) < scopeSize(closest)) {
            return scope;
        }

        return closest;
    });
}

function buildSuggestion(info, text, _ref2) {
    var start = _ref2.start,
        end = _ref2.end;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var paths = info.paths,
        scopes = info.scopes,
        externalModules = info.externalModules;


    for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        if (path.range.start > end) {
            break;
        }
        if (path.range.start <= start && path.range.end >= end) {

            if (path.imported !== 'default') {
                return {
                    type: 'from-import',
                    imported: path.imported,
                    moduleName: path.moduleName,
                    bindingStart: path.range.start,
                    bindingEnd: path.range.end
                };
            }

            return {
                type: 'path',
                imported: path.imported,
                moduleName: path.moduleName,
                range: path.range
            };
        }
    }

    var closestScope = findClosestScope(scopes, start, end);
    // Sometimes it reports it has a binding, but it can't actually get the
    // binding
    if (closestScope.hasBinding(text) && closestScope.getBinding(text)) {
        var _ret = function () {
            var binding = closestScope.getBinding(text);
            var _binding$identifier = binding.identifier,
                bindingStart = _binding$identifier.start,
                bindingEnd = _binding$identifier.end;


            var clickedDeclaration = bindingStart <= start && bindingEnd >= end;
            var crossFiles = !options.jumpToImport;

            if (clickedDeclaration || crossFiles) {
                var targetModule = externalModules.find(function (m) {
                    var bindingStart = binding.identifier.start;

                    return m.local == text && m.start == bindingStart;
                });

                if (targetModule) {
                    return {
                        v: _extends({}, targetModule, {
                            type: 'from-import',
                            bindingStart: bindingStart,
                            bindingEnd: bindingEnd
                        })
                    };
                }
            }

            // Exit early if you clicked on where the variable is declared
            if (clickedDeclaration) {
                return {
                    v: null
                };
            }

            return {
                v: {
                    type: 'binding',
                    start: bindingStart,
                    end: bindingEnd
                }
            };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    return null;
}